{"id":1374936500,"question_id":3551,"lang":"cpp","lang_name":"C++","time":"3Â months","timestamp":1725163255,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1374936500/","is_pending":"Not Pending","title":"Maximum XOR Score Subarray Queries","memory":"N/A","code":"class Solution {\npublic:\n    int xorScore(vector<int> a) {\n        int N = (int)a.size();\n        for (int i = 1; i < N; i++)\n            for (int j = N - 1; j >= i; j--)\n                a[j] = a[j] ^ a[j - 1];\n        return a[N - 1];\n    }\n\n    struct Trie {\n        vector<Trie*> pt;\n        bool en = false;\n        Trie() { pt = vector<Trie*>(2, nullptr); }\n        auto insert(string s) {\n            if (s.empty())\n                return (en = true);\n            if (pt[s[0] - '0'] == nullptr) {\n                pt[s[0] - '0'] = new Trie();\n            }\n            return pt[s[0] - '0']->insert(s.substr(1));\n        }\n        int search(string s, int i) {\n            if (s.empty() || i == 0)\n                return 0;\n            if (s[0] - '0' == 0 && pt[1] != nullptr)\n                return (1 << i) + pt[1]->search(s.substr(1), i - 1);\n            if (s[0] - '0' == 1 && pt[0] != nullptr)\n                return (1 << i) + pt[0]->search(s.substr(1), i - 1);\n            if (pt[0] != nullptr)\n                return pt[0]->search(s.substr(1), i - 1);\n            if (pt[1] != nullptr)\n                return pt[1]->search(s.substr(1), i - 1);\n            return 0;\n        }\n    };\n\n    string ston(int i) {\n        bitset<32> b(i);\n        return b.to_string();\n    }\n\n    // class Node {\n    // public:\n    //     Node* left;  // 0\n    //     Node* right; // 1\n    // };\n\n    // class MXOR {\n    // public:\n    //     Node* root;\n    //     MXOR() { root = new Node(); }\n    //     void insert(int n) {\n    //         Node* temp = root;\n    //         for (int i = 31; i >= 0; i--) {\n    //             int currentBit = (n >> i) & 1;\n    //             if (!currentBit) {\n    //                 if (!temp->left)\n    //                     temp->left = new Node();\n    //                 temp = temp->left;\n    //             } else {\n    //                 if (!temp->right)\n    //                     temp->right = new Node();\n    //                 temp = temp->right;\n    //             }\n    //         }\n    //     }\n\n    //     int helper(int val) {\n    //         int ans = 0;\n    //         Node* temp = root;\n\n    //         for (int i = 31; i >= 0; i--) {\n    //             int currentBit = (val >> i) & 1;\n\n    //             if (!currentBit) {\n    //                 if (temp->right) {\n    //                     temp = temp->right;\n    //                     ans += (1 << i);\n    //                 } else\n    //                     temp = temp->left;\n\n    //             } else {\n    //                 if (temp->left) {\n    //                     temp = temp->left;\n    //                     ans += (1 << i);\n    //                 } else\n    //                     temp = temp->right;\n    //             }\n    //         }\n\n    //         return ans;\n    //     }\n\n    //     // O(n)\n    //     int findMaximumXOR(vector<int>& arr) {\n    //         int n = arr.size();\n    //         int res = 0;\n    //         for (int i = 0; i < n; i++) {\n    //             int value = arr[i];\n    //             insert(value);\n    //             int curAns = helper(value);\n    //             res = max(curAns, res);\n    //         }\n    //         return res;\n    //     }\n    // };\n\n    class Node {\n    public:\n        Node* one;\n        Node* zero;\n    };\n\n    class trie {\n        Node* root;\n\n        public:\n        trie() { root = new Node(); }\n\n        void insert(int n) {\n            Node* temp = root;\n            for (int i = 31; i >= 0; i--) {\n                int bit = (n >> i) & 1;\n                if (bit == 0) {\n                    if (temp->zero == NULL) {\n                        temp->zero = new Node();\n                    }\n                    temp = temp->zero;\n                } else {\n                    if (temp->one == NULL) {\n                        temp->one = new Node();\n                    }\n                    temp = temp->one;\n                }\n            }\n        }\n\n        int helper(int value) {\n            Node* temp = root;\n            int current_ans = 0;\n\n            for (int i = 31; i >= 0; i--) {\n                int bit = (value >> i) & 1;\n                if (bit == 0) {\n                    if (temp->one) {\n                        temp = temp->one;\n                        current_ans += (1 << i);\n                    } else {\n                        temp = temp->zero;\n                    }\n                } else {\n                    if (temp->zero) {\n                        temp = temp->zero;\n                        current_ans += (1 << i);\n                    } else {\n                        temp = temp->one;\n                    }\n                }\n            }\n            return current_ans;\n        }\n\n        int max_xor(int arr[], int n) {\n            int max_val = 0;\n            insert(arr[0]);\n            for (int i = 1; i < n; i++) {\n                max_val = max(helper(arr[i]), max_val);\n                insert(arr[i]);\n            }\n            return max_val;\n        }\n    };\n\n    vector<int> maximumSubarrayXor(vector<int>& nums,\n                                   vector<vector<int>>& queries) {\n        vector<int> ans;\n        int N = (int)nums.size();\n        for (auto q : queries) {\n            trie* t = new trie();\n            // MXOR* t = new MXOR();\n            int mx = 0;\n            t->insert(q[0]);\n            for (int i = q[0]+1; i <= q[1]; i += 2) {\n                mx = max(mx, t->helper(nums[i]));\n                t->insert(nums[i]);\n            }\n            t = new trie();\n            t->insert(nums[q[0]] ^ nums[q[0]+1]);\n            for (int i = q[0] + 2; i <= q[1]; i += 2) {\n                mx = max(mx, t->helper(nums[i] ^ nums[i - 1]));\n                t->insert(nums[i] ^ nums[i - 1]);\n            }\n            ans.push_back(mx);\n        }\n        return ans;\n    }\n};","compare_result":"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"maximum-xor-score-subarray-queries","has_notes":false,"flag_type":1}