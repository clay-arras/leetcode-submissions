{"id":1239487670,"question_id":310,"lang":"cpp","lang_name":"C++","time":"7 months, 2 weeks","timestamp":1713835572,"status":12,"status_display":"Memory Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1239487670/","is_pending":"Not Pending","title":"Minimum Height Trees","memory":"N/A","code":"class Solution {\npublic:\n    const static int MAXN = 2e4+4;\n    vector<int> adj_list[MAXN];\n    vector<bool> visited;\n\n    void dfs(int s, int count, int& maxCount, int& maxNode) {\n        visited[s] = true;\n        count++;\n        if (count >= maxCount) {\n            maxCount = count;\n            maxNode = s;\n        }\n\n        for (int i : adj_list[s]) {\n            if (!visited[i]) {\n                dfs(i, count, maxCount, maxNode);\n            }\n        }\n    }\n\n    vector<int> bfs(int st, int en, int dist, int n) {\n        vector<vector<int>> paths = vector<vector<int>>(n, vector<int>());\n        queue<int> q;\n        q.push(st);\n\n        while (!q.empty()) {\n            int s = q.front();\n            q.pop();\n            visited[s] = true;\n\n            if (s == en) {\n                break;\n            }\n\n            for (int i : adj_list[s]) {\n                if (!visited[i]) {\n                    q.push(i);\n                    paths[i].assign(paths[s].begin(), paths[s].end());\n                    paths[i].push_back(s);\n                }\n            }\n        }\n        paths[en].push_back(en);\n        for (int i=0, len=(int)paths[en].size(); i<len; i++) {\n            if (len % 2 && i == dist) {\n                return {paths[en][i]};\n            } else if (len % 2 == 0 && i == dist){\n                return {paths[en][i-1], paths[en][i]};\n            }\n        }\n        return {};\n    }\n\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        for (auto e : edges) {\n            adj_list[e[0]].push_back(e[1]);\n            adj_list[e[1]].push_back(e[0]);\n        }\n        \n        int n1 = 0, n2 = 0, dist = 0;\n        visited = vector<bool> (n, false);\n        dfs(0, 0, dist, n1);\n        fill(visited.begin(), visited.end(), false);\n        dfs(n1, 0, dist = 0, n2);\n        fill(visited.begin(), visited.end(), false);\n\n        return  bfs(n1, n2, floor(dist*1.0/2), n);\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111110","title_slug":"minimum-height-trees","has_notes":false,"flag_type":1}