{"id":1239492206,"question_id":310,"lang":"cpp","lang_name":"C++","time":"7 months, 2 weeks","timestamp":1713836195,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1239492206/","is_pending":"Not Pending","title":"Minimum Height Trees","memory":"N/A","code":"class Solution {\npublic:\n    const static int MAXN = 2e4+4;\n    vector<int> adj_list[MAXN];\n    vector<bool> visited;\n\n    void dfs(int s, int count, int& maxCount, int& maxNode) {\n        visited[s] = true;\n        count++;\n        if (count >= maxCount) {\n            maxCount = count;\n            maxNode = s;\n        }\n\n        for (int i : adj_list[s]) {\n            if (!visited[i]) {\n                dfs(i, count, maxCount, maxNode);\n            }\n        }\n    }\n\n    vector<int> bfs(int st, int en, int dist, int n) {\n        queue<vector<int>> paths;\n        queue<int> q;\n        q.push(st);\n        paths.push({});\n        vector<int> p = {};\n\n        while (!q.empty()) {\n            int s = q.front();\n            vector<int> path = paths.front();\n            q.pop();\n            paths.pop();\n            visited[s] = true;\n\n            if (s == en) {\n                p = path;\n                break;\n            }\n\n            for (int i : adj_list[s]) {\n                if (!visited[i]) {\n                    q.push(i);\n                    for (int i : path)\n                        cout << i << \" \";\n                    cout << endl;\n                    cout << endl;\n                    path.push_back(s);\n                    paths.push(path);\n                }\n            }\n        }\n\n        p.push_back(en);\n        for (int i : p)\n            cout << i << \" \";\n        cout << endl;\n        cout << endl;\n        for (int i=0, len=(int)p.size(); i<len; i++) {\n            if (len % 2 && i == dist) {\n                return {p[i]};\n            } else if (len % 2 == 0 && i == dist){\n                return {p[i-1], p[i]};\n            }\n        }\n        return {};\n    }\n\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        for (auto e : edges) {\n            adj_list[e[0]].push_back(e[1]);\n            adj_list[e[1]].push_back(e[0]);\n        }\n        \n        int n1 = 0, n2 = 0, dist = 0;\n        visited = vector<bool> (n, false);\n        dfs(0, 0, dist, n1);\n        fill(visited.begin(), visited.end(), false);\n        dfs(n1, 0, dist = 0, n2);\n        fill(visited.begin(), visited.end(), false);\n        vector<int> ans = bfs(n1, n2, floor(dist*1.0/2), n);\n\n        return ans;\n    }\n};","compare_result":"01111000001011010000010001111000001100110100000110111011010111000000000","title_slug":"minimum-height-trees","has_notes":false,"flag_type":1}