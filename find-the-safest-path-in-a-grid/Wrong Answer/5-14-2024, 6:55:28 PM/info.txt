{"id":1258305938,"question_id":2914,"lang":"cpp","lang_name":"C++","time":"6 months, 3 weeks","timestamp":1715738128,"status":11,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/1258305938/","is_pending":"Not Pending","title":"Find the Safest Path in a Grid","memory":"N/A","code":"class Solution {\npublic:\n    int N;\n    vector<vector<int>> g;\n\n    void fill(int i, int j) {\n        queue<pair<int, int>> q;\n        vector<vector<int>> d(N, vector<int>(N, INT_MAX));\n        q.push({i, j});\n        d[i][j] = 0;\n        g[i][j] = 0;\n        \n        while (!q.empty()) {\n            auto [x, y] = q.front(); q.pop();\n            if (x + 1 < N && d[x+1][y] == INT_MAX) {\n                d[x+1][y] = d[x][y]+1;\n                g[x+1][y] = min(g[x+1][y], d[x+1][y]);\n                q.push({x+1, y});\n            }\n            if (y + 1 < N && d[x][y+1] == INT_MAX) {\n                d[x][y+1] = d[x][y]+1;\n                g[x][y+1] = min(g[x][y+1], d[x][y+1]);\n                q.push({x, y+1});\n            }\n            if (x - 1 >= 0 && d[x-1][y] == INT_MAX) {\n                d[x-1][y] = d[x][y]+1;\n                g[x-1][y] = min(g[x-1][y], d[x-1][y]);\n                q.push({x-1, y});\n            }\n            if (y - 1 >= 0 && d[x][y-1] == INT_MAX) {\n                d[x][y-1] = d[x][y]+1;\n                g[x][y-1] = min(g[x][y-1], d[x][y-1]);\n                q.push({x, y-1});\n            }\n        }\n    }\n\n    // int lastTrue(int l, int r, function<bool(int)> f) {\n    //     for (int diff=r-l, l=l-1; diff>0; diff/=2) \n    //         while (l + diff <= r && f(l + diff)) \n    //             l += diff; \n    //     return l;\n    // }\n    int lastTrue(int lo, int hi, function<bool(int)> f) {\n        lo--;\n        for (int dif=hi-lo; dif>0; dif/=2) {\n            while (lo + dif <= hi && f(lo + dif)) { lo += dif; }\n        }\n        return lo;\n    }\n\n    bool ok(int k) {\n        vector<vector<bool>> visited(N, vector<bool>(N, false)); \n        return dfs(0, 0, visited, k);\n    }\n\n    bool dfs(int x, int y, vector<vector<bool>>& visited, int k) {\n        visited[x][y] = true;\n\n        bool ans = (x == N-1 && y == N-1);\n        if (x + 1 < N && !visited[x+1][y] && g[x+1][y] >= k) \n            ans |= dfs(x+1, y, visited, k);\n        if (y + 1 < N && !visited[x][y+1] && g[x][y+1] >= k) \n            ans |= dfs(x, y+1, visited, k);\n        if (x - 1 >= 0 && !visited[x-1][y] && g[x-1][y] >= k) \n            ans |= dfs(x-1, y, visited, k);\n        if (y - 1 >= 0 && !visited[x][y-1] && g[x][y-1] >= k) \n            ans |= dfs(x, y-1, visited, k);\n        \n        return ans;\n    }\n\n    int maximumSafenessFactor(vector<vector<int>>& grid) {\n        N = (int)grid.size();\n        vector<pair<int, int>> thieves;\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                if (grid[i][j])\n                    thieves.push_back({i, j});\n\n        g = vector<vector<int>>(N, vector<int>(N, INT_MAX));\n        vector<vector<bool>> visited;\n        for (auto [i, j] : thieves) \n            fill(i, j);\n\n        return lastTrue(0, 2*N-1, [&](int k) -> bool {\n            vector<vector<bool>> visited(N, vector<bool>(N, false)); \n            return dfs(0, 0, visited, k);\n        });\n        // return lastTrue(0, 2*N-1, &ok);\n    }\n};","compare_result":"1110111111111111111111111111111111111111111110111111101110111010101010111111111111111111111111111111111011111110111111101110111010101010111111111111111111110111010101010011111110111111101110111010101010111111111101010101110111010101010011111110101010101110111010101001111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111101111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111011111111111111111111111111111111111111111110111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111110111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000","title_slug":"find-the-safest-path-in-a-grid","has_notes":false,"flag_type":1}