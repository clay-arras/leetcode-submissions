{"id":1258331853,"question_id":2914,"lang":"cpp","lang_name":"C++","time":"6 months, 3 weeks","timestamp":1715741398,"status":12,"status_display":"Memory Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1258331853/","is_pending":"Not Pending","title":"Find the Safest Path in a Grid","memory":"N/A","code":"class Solution {\npublic:\n    const static short int MXN = 4e2;\n    short int N;\n    vector<vector<short int>> g;\n\n    void fill(short int i, short int j) {\n        queue<pair<short int, short int>> q;\n        vector<vector<short int>> d(N, vector<short int>(N, SHRT_MAX));\n        q.push({i, j});\n        d[i][j] = 0, g[i][j] = 0;\n\n        while (!q.empty()) {\n            auto [x, y] = q.front();\n            q.pop();\n            if (x + 1 < N && d[x + 1][y] == SHRT_MAX) {\n                d[x + 1][y] = d[x][y] + 1;\n                if (g[x + 1][y] >= d[x + 1][y]) {\n                    g[x + 1][y] = min(g[x + 1][y], d[x + 1][y]);\n                    q.push({x + 1, y});\n                }\n            }\n            if (y + 1 < N && d[x][y + 1] == SHRT_MAX) {\n                d[x][y + 1] = d[x][y] + 1;\n                if (g[x][y + 1] >= d[x][y + 1]) {\n                    g[x][y + 1] = min(g[x][y + 1], d[x][y + 1]);\n                    q.push({x, y + 1});\n                }\n            }\n            if (x - 1 >= 0 && d[x - 1][y] == SHRT_MAX) {\n                d[x - 1][y] = d[x][y] + 1;\n                if (g[x - 1][y] >= d[x - 1][y]) {\n                    g[x - 1][y] = min(g[x - 1][y], d[x - 1][y]);\n                    q.push({x - 1, y});\n                }\n            }\n            if (y - 1 >= 0 && d[x][y - 1] == SHRT_MAX) {\n                d[x][y - 1] = d[x][y] + 1;\n                if (g[x][y - 1] >= d[x][y - 1]) {\n                    g[x][y - 1] = min(g[x][y - 1], d[x][y - 1]);\n                    q.push({x, y - 1});\n                }\n            }\n        }\n    }\n\n    short int lastTrue(short int lo, short int hi, function<bool(short int)> f) {\n        lo--;\n        for (short int dif = hi - lo; dif > 0; dif /= 2) {\n            while (lo + dif <= hi && f(lo + dif)) {\n                lo += dif;\n            }\n        }\n        return lo;\n    }\n\n    bool dfs(short int x, short int y, vector<bitset<MXN>>& visited, short int k) {\n        visited[x][y] = true;\n\n        bool ans = (x == N - 1 && y == N - 1 && g[x][y] >= k);\n        if (x + 1 < N && !visited[x + 1][y] && g[x + 1][y] >= k && !ans)\n            ans |= dfs(x + 1, y, visited, k);\n        if (y + 1 < N && !visited[x][y + 1] && g[x][y + 1] >= k && !ans)\n            ans |= dfs(x, y + 1, visited, k);\n        if (x - 1 >= 0 && !visited[x - 1][y] && g[x - 1][y] >= k && !ans)\n            ans |= dfs(x - 1, y, visited, k);\n        if (y - 1 >= 0 && !visited[x][y - 1] && g[x][y - 1] >= k && !ans)\n            ans |= dfs(x, y - 1, visited, k);\n\n        return ans;\n    }\n\n    int maximumSafenessFactor(vector<vector<int>>& grid) {\n        N = (short int)grid.size();\n        g = vector<vector<short int>>(N, vector<short int>(N, SHRT_MAX));\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                if (grid[i][j])\n                    fill(i, j);\n        \n        // for (int i=0; i<N; i++) {\n        //     for (int j=0; j<N; j++)\n        //         cout << g[i][j] << \" \";\n        //     cout << endl;\n        // }\n\n        return lastTrue(0, 2 * N - 1, [&](short int k) -> bool {\n            vector<bitset<MXN>> visited(N);\n            return (g[0][0] >= k && dfs(0, 0, visited, k));\n        });\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000","title_slug":"find-the-safest-path-in-a-grid","has_notes":false,"flag_type":1}