{"id":1441437756,"question_id":3637,"lang":"cpp","lang_name":"C++","time":"1Â month","timestamp":1730609793,"status":14,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/1441437756/","is_pending":"Not Pending","title":"Count Number of Balanced Permutations","memory":"N/A","code":"class Solution {\npublic:\n\nstruct Int256 {\n    uint64_t parts[4];  // Represents the 256-bit integer as four 64-bit parts\n\n    // Constructor initializes with zero by default\n    Int256(uint64_t low = 0) {\n        parts[0] = low;\n        parts[1] = parts[2] = parts[3] = 0;\n    }\n\n    // Add operator\n    Int256 operator+(const Int256& other) const {\n        Int256 result;\n        uint64_t carry = 0;\n        for (int i = 0; i < 4; i++) {\n            uint64_t temp = parts[i] + other.parts[i] + carry;\n            result.parts[i] = temp;\n            carry = (temp < parts[i]) ? 1 : 0;\n        }\n        return result;\n    }\n\n    // Subtract operator\n    Int256 operator-(const Int256& other) const {\n        Int256 result;\n        uint64_t borrow = 0;\n        for (int i = 0; i < 4; i++) {\n            uint64_t temp = parts[i] - other.parts[i] - borrow;\n            result.parts[i] = temp;\n            borrow = (parts[i] < other.parts[i] + borrow) ? 1 : 0;\n        }\n        return result;\n    }\n\n    // Multiply operator\n    Int256 operator*(const Int256& other) const {\n        Int256 result;\n        std::vector<uint64_t> temp(8, 0);\n\n        // Perform multiplication part by part\n        for (int i = 0; i < 4; i++) {\n            uint64_t carry = 0;\n            for (int j = 0; j < 4; j++) {\n                __uint128_t mul = (__uint128_t)parts[i] * other.parts[j] + temp[i + j] + carry;\n                temp[i + j] = (uint64_t)mul;\n                carry = (uint64_t)(mul >> 64);\n            }\n            temp[i + 4] = carry;\n        }\n\n        // Copy the result back into the Int256 structure\n        for (int i = 0; i < 4; i++) {\n            result.parts[i] = temp[i];\n        }\n\n        return result;\n    }\n    bool operator>=(const Int256& other) const {\n        for (int i = 3; i >= 0; --i) {\n            if (parts[i] > other.parts[i]) return true;\n            if (parts[i] < other.parts[i]) return false;\n        }\n        return true;\n    }\n\n    Int256 operator<<(int shift) const {\n        Int256 result;\n        int fullShifts = shift / 64;\n        int bitShift = shift % 64;\n        for (int i = 3; i >= fullShifts; --i) {\n            result.parts[i] = parts[i - fullShifts] << bitShift;\n            if (i - fullShifts - 1 >= 0 && bitShift != 0) {\n                result.parts[i] |= parts[i - fullShifts - 1] >> (64 - bitShift);\n            }\n        }\n        return result;\n    }\n\n\n    // Division operator (assuming simple division by a small 64-bit integer)\n    Int256 operator/(const Int256& divisor) const {\n        Int256 quotient, remainder;\n        for (int i = 255; i >= 0; --i) {\n            remainder = remainder << 1;  // Left shift remainder\n            remainder.parts[0] |= (parts[i / 64] >> (i % 64)) & 1;  // Add the bit\n\n            if (remainder >= divisor) {\n                remainder = remainder - divisor;\n                quotient.parts[i / 64] |= (1ULL << (i % 64));\n            }\n        }\n\n        return quotient;\n    }\n\n\n    // Convert to long long (may overflow if the value doesn't fit)\n    long long convertToLongLong() const {\n        if (parts[1] || parts[2] || parts[3]) {\n            throw std::overflow_error(\"Int256 value is too large to fit in a long long\");\n        }\n        return static_cast<long long>(parts[0]);\n    }\n    long long mod(long long divisor) const {\n        if (divisor == 0) {\n            throw std::overflow_error(\"Modulo by zero\");\n        }\n\n        __int128_t remainder = 0;  // To handle intermediate values larger than long long\n        for (int i = 3; i >= 0; --i) {\n            remainder = (remainder << 64) + parts[i];\n            remainder %= divisor;\n        }\n        return static_cast<long long>(remainder);\n    }\n\n\n    // Print for debugging purposes\n    void print() const {\n        std::cout << \"Int256(\";\n        for (int i = 3; i >= 0; i--) {\n            std::cout << parts[i];\n            if (i > 0) std::cout << \", \";\n        }\n        std::cout << \")\" << std::endl;\n    }\n\n};\n\n\n\n\n\n    int target;\n    vector<int> rest;\n    long long ans = 0;\n    long long MOD = 1e9+7;\n    Int256 f[41];\n    \n    Int256 mod_init(int n) {\n        f[0] = 1;\n        for(int i=1;i<=n;i = i+1) {\n            f[i] = (Int256(i) * f[i-1]);\n        }\n        return f[n];\n    }\n\n    void subsets(vector<int> arr, int sum, int index) {\n        \n        if (sum > target) return;\n        if ((int)arr.size() > (int)rest.size()/2) return;\n        \n        if (sum == target && (int)arr.size() == (int)rest.size()/2) {\n            \n            unordered_map<int, int> m;\n            for (int i : arr)\n                m[i]++;\n            \n            Int256 add = f[((int)rest.size()/2)];\n            for (auto [k, v] : m) {\n                add = add / f[(v)];\n            }\n\n            unordered_map<int, int> m2;\n            for (int i : rest) {\n                if (m[i] == 0) \n                    m2[i]++; \n                else  m[i]--;\n            }\n            Int256 add2 = f[(int)(ceil((int)rest.size()*1.0/2))];\n            for (auto [k, v] : m2) {\n                add2 = add2 / f[(v)];\n            }\n            ans = (ans + ((add2*add).mod(MOD))) % MOD;\n            return;\n        }\n\n        int last = -1;\n        for (int i=index; i<(int)rest.size(); i++) {\n            if (rest[i] == last) continue;\n            arr.push_back(rest[i]);\n            sum += rest[i];\n            subsets(arr, sum, i+1);\n            last = rest[i];\n            arr.pop_back();\n            sum -= rest[i];\n        }\n    }\n\n    int countBalancedPermutations(string num) {\n        mod_init(40);\n        // __int256 i  = 0;\n\n        for (char c : num) {\n            target += c - '0';\n            rest.push_back(c - '0');\n        }\n        sort(rest.begin(), rest.end());\n        if (target % 2) return 0;\n        target /= 2;\n\n        subsets({}, 0, 0);\n        return ans;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"count-number-of-balanced-permutations","has_notes":false,"flag_type":1}