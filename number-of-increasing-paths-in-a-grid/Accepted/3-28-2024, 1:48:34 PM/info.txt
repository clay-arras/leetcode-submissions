{"id":1216746736,"question_id":2409,"lang":"cpp","lang_name":"C++","time":"8 months, 1 week","timestamp":1711658914,"status":10,"status_display":"Accepted","runtime":"343 ms","url":"/submissions/detail/1216746736/","is_pending":"Not Pending","title":"Number of Increasing Paths in a Grid","memory":"78.2 MB","code":"class Solution {\npublic:\n    const static int MAXN = 1e3+4;\n    const static int MOD = 1e9+7;\n    long long dp[MAXN][MAXN];\n\n    int countPaths(vector<vector<int>>& grid) {\n        priority_queue<pair<int, pair<int, int>>> pq;\n\n        int M = (int)grid[0].size(), N = (int)grid.size();\n        for (int i=0; i<N; i++)\n            for (int j=0; j<M; j++)\n                pq.push({-grid[i][j], {i, j}});\n        \n        while (!pq.empty()) {\n            int val = -pq.top().first;\n            int i = pq.top().second.first;\n            int j = pq.top().second.second;\n            pq.pop();\n\n            dp[i][j] = 1;\n            if (i - 1 >= 0 && val > grid[i-1][j]) {\n                dp[i][j] += dp[i-1][j];\n                dp[i][j] %= MOD;\n            }\n            if (j - 1 >= 0 && val > grid[i][j-1]) {\n                dp[i][j] += dp[i][j-1];\n                dp[i][j] %= MOD;\n            }\n            if (i + 1 < N && val > grid[i+1][j]) {\n                dp[i][j] += dp[i+1][j];\n                dp[i][j] %= MOD;\n            }\n            if (j + 1 < M && val > grid[i][j+1]) {\n                dp[i][j] += dp[i][j+1];\n                dp[i][j] %= MOD;\n            }\n            dp[i][j] %= MOD;\n        }\n        long long ans = 0;\n        for (int i=0; i<N; i++)\n            for (int j=0; j<M; j++)\n                ans = (ans + dp[i][j]) % MOD;\n\n        return ans;\n    }\n};","compare_result":"111111111111111111111111111111111111","title_slug":"number-of-increasing-paths-in-a-grid","has_notes":false,"flag_type":1}